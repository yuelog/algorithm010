#本周学习数据结构

###树
可以看做是链表的升维
树和图最根本的区别是会不会形成环(树可以看成是特殊的图)
三种遍历方式(前中后序遍历,时间复杂度都为O(n),空间复杂度平均为O(logn),最坏为O(n))
插入删除查询的时间复杂度都是O(logn)
删除操作如果删除的不是叶子节点,原则是直接拿该节点右子树第一个大于它的节点补上


###堆
求最大最小值
最大堆 => 根节点最大的堆
最小堆 => 根节点最小的堆
常见的堆有二叉堆(面试常用,是堆的简单实现,但并不是最优实现,一般工程中直接使用优先队列[语言一般自带或有第三方库支持])、斐波那契堆(工业级比较牛逼的应用会用,时空间复杂度会比二叉堆更好[其是多叉的],是由多叉树来实现)

相关时间复杂度
find-max => O(1)
delete => O(logn)
insert => O(logn) or O(1)i[斐波那契堆]

###图
图近年来作为面试题较少,工程中也比较少遇到
图是由边和点构成的数据结构,其中点包含(度:出度、入度, 点与点之间连通与否);边包含(有向无向,权重)
根据边和点的特性可以简单分为 无向无权图,无向有权图,有向无权图,有向有权图(记得大概的邻接矩阵和邻接表画法)
初级算法:记得图实现DFS和BFS(!!尤其别忘了开始的visited集合[树不需要,图中用这个去重])


#本周学习到的一些解题方法
1. 递归
2. 广度优先
